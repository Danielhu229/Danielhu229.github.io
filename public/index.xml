<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Daniel&#39;s mind paradise</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on Daniel&#39;s mind paradise</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 09 Apr 2019 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Danielhu</title>
      <link>http://localhost:1313/about/</link>
      <pubDate>Sun, 18 Feb 2018 22:05:02 +0000</pubDate>
      
      <guid>http://localhost:1313/about/</guid>
      
        <description>&lt;p&gt;Hi，I &amp;rsquo;m Daniel, A Game developer &amp;amp; graphics researcher now working in Tencent.&lt;/p&gt;

&lt;p&gt;If you like, have a look at some of my interesting projects on github:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/Danielhu229/CanvasToy&#34;&gt;CanvasToy&lt;/a&gt;&lt;/strong&gt;
A WebGL rendering library witch supports physical-based rendering, also formed a tile-based deferred rendering pipeline.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/Danielhu229/Lexacc&#34;&gt;Lexacc&lt;/a&gt;&lt;/strong&gt;
A compiler-front-end parser generator&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;yimingdz@gmail.com&#34;&gt;yimingdz@gmail.com&lt;/a&gt;, any technical or academic discussion is welcome.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>I&#39;ve paid my dues, time after time.</title>
      <link>http://localhost:1313/post/i-ve-paid-my-dues-time-after-time/</link>
      <pubDate>Tue, 09 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/i-ve-paid-my-dues-time-after-time/</guid>
      
        <description>&lt;p&gt;在如此长远的一辈子的尺度上看，我是如此幸运。&lt;/p&gt;

&lt;p&gt;不是所有 bug 都有机会暴露，不是所有人都能做单元测试&lt;/p&gt;

&lt;p&gt;为什么男生一个人就会过的邋遢呢？我自觉收拾的很好，虽然我少年时代被家里说不会收拾东西&lt;/p&gt;

&lt;p&gt;已经捡起来原来的爱好，已经重新认识人，重新处在一个能共情的环境&lt;/p&gt;

&lt;p&gt;作为独立的个体, 期望真正完整的爱情&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>现代C&#43;&#43;惯用法</title>
      <link>http://localhost:1313/post/%E7%8E%B0%E4%BB%A3c-%E6%83%AF%E7%94%A8%E6%B3%95/</link>
      <pubDate>Wed, 06 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E7%8E%B0%E4%BB%A3c-%E6%83%AF%E7%94%A8%E6%B3%95/</guid>
      
        <description>

&lt;p&gt;现在是 9102 年了，再来总结 C++ 的惯用法似乎有点落伍，但是 C++ 的强大依然毋庸置疑。最近我也把目光投向 rust，C++ 不管怎么演进，历史包袱还是太沉重了。而且，rust 的设计其实也参考了很多C++的思想（如 RAII）所以在 C++ 中继续深入也是有价值的&lt;/p&gt;

&lt;h2 id=&#34;内容大纲&#34;&gt;内容大纲&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Assertion&lt;/li&gt;
&lt;li&gt;Marcos&lt;/li&gt;
&lt;li&gt;SFINAE&lt;/li&gt;
&lt;li&gt;Meyers Singleton&lt;/li&gt;
&lt;li&gt;RAII&lt;/li&gt;
&lt;li&gt;Type Trait&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;0-assertion&#34;&gt;0. Assertion&lt;/h1&gt;

&lt;h2 id=&#34;运行期断言&#34;&gt;运行期断言&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#ifdef NDEBUG
#define assert(condition) ((void)0)
#else
#define assert(condition) /*implementation defined*/
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;assert 其实是在来源于C语言的头文件&lt;cassert&gt; 中定义的宏&lt;/p&gt;

&lt;p&gt;一般来说，如果condition 是false，那么assert 首先向stderr 打印错误信息，然后调用 abort (触发一个SIGABRT中断信号)来非正常结束程序&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;assert 不是 error handling, assertion 处理的是&lt;strong&gt;代码的 bug&lt;/strong&gt; 而不是程序预期的输入错误或者系统错误等&lt;/li&gt;
&lt;li&gt;想象有这样一个函数，下面哪种实现更”安全“呢？：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void foo1(int score) {
    if(score &amp;gt; 0 &amp;amp;&amp;amp; score &amp;lt;= 100）{
        // internal logics
    }    
}
       
void foo2(int score) {
    // require bar between 1 and 100
    assert(score &amp;gt; 0 &amp;amp;&amp;amp; score &amp;lt;= 100 &amp;amp;&amp;amp; &amp;quot;score must between 1 and  100！&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;foo1看起来是安全的，因为程序没有崩溃，很完美，可惜没有对异常输入做任何处理，因此来自调用方的逻辑错误就被隐藏了&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在这里，assert 和 if 都提供了一个内置的validate检查，在执行真正的逻辑之前，模块的开发者可以视为自己对外部调用做了一个“假设”，这样就把异常处理的责任转移到调用端，开发者只需要关注自己的逻辑闭环。不同的是，assert能发现外部调用的错误&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;让错误尽早发现-fail-fast-1&#34;&gt;让错误尽早发现(Fail Fast[1])&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一个 fail fast 的系统通常倾向于直接报告错误给上层逻辑。&lt;/li&gt;
&lt;li&gt;此类设计通常会在操作中的多个点检查系统的状态，因此可以及早检测到故障。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;assert-优点&#34;&gt;assert 优点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;帮助程序员做好模块化&lt;/li&gt;
&lt;li&gt;在内部逻辑执行之前提供可行性检查&lt;/li&gt;
&lt;li&gt;造成程序的 fast fail&lt;/li&gt;
&lt;li&gt;在 release 模式下会被 compiled out, 不影响性能&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;缺点&#34;&gt;缺点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;只在 debug 模式下工作，如果在 assert 中写有副作用的逻辑，会造成 release 版本的严重错误&lt;/li&gt;
&lt;li&gt;使得程序的内在逻辑对外部部分可见&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;编译期断言&#34;&gt;编译期断言&lt;/h2&gt;

&lt;p&gt;编译期断言对应 static_assert，是 C++ 11 提供的让错误更早发现的机制。&lt;/p&gt;

&lt;p&gt;static_assert 十分强大，附带的自定义信息会直接被当成编译错误输出，但由于是编译期断言，因此限制也很大。他的输入只能是bool_constexpr类型。因此要用好static assert，需要程序员分辨出代码哪些部分是&lt;strong&gt;编译期&lt;/strong&gt;即可确定的部分。&lt;/p&gt;

&lt;p&gt;下面的代码可以限制 Vector 的 dimension 始终大于 1&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename ElemType, int N&amp;gt;
class Vector {
    static_assert(N &amp;gt; 1, &amp;quot;1D Vector is not allowed, use scalar types&amp;quot;);
    ElemType elem_[N];
};

Vector&amp;lt;int, 1&amp;gt; vec1;// compilation error
Vector&amp;lt;int, 2&amp;gt; vec2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，利用 static_assert + type_traits 也能实现语义约束，比如我们想写一个检查无符号加法溢出的函数，并希望调用方不传递有符号类型，那么我们可以：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
bool check_overflow_add_unsigned(T a, T b) {
    static_assert(std::is_unsigned&amp;lt;T&amp;gt;::value, &amp;quot;T must be unsigned types!&amp;quot;);
    ...
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于自 C++ 11 开始，鼓励大家多用编译期计算，把一些 constant 的数据和代码段尽量挪到编译期，因此可能很多类型成为 literal type （比如上面的 Vector ）。这些类既能在运行期运行，又能在编译期预计算，因此，只要是涉及 literal type 的函数/类/对象  就应尽可能的用 static_assert&lt;/p&gt;

&lt;h1 id=&#34;1-marcos&#34;&gt;1. Marcos&lt;/h1&gt;

&lt;p&gt;这里说的宏是指 replacing text macros，是由预处理器支持的文本替换功能，同样支持带参数的文本替换&lt;/p&gt;

&lt;p&gt;宏是许多编程语言都支持的功能，C/C++ 中的宏是较为简单的文本替换，而在 rust 和 lisp 等语言中，宏会直接展开AST，因此更为强大，既有类型系统支持，又能做到zero cost abstraction&lt;/p&gt;

&lt;p&gt;尽管如此，在C/C++中 使用宏很多时候能大大简化代码，在一些情况下能代替C/C++中比较啰嗦的逻辑。例如当我们想在每个类的定义插入特定的信息用来做反射，以及当我们想做一个循环展开以便更好的利用SIMD的性能，宏都能给我们提供这样的能力，但有时候也会给开发者带来困惑，尤其多层嵌套的宏在可读性和维护性上比较差。但目前，宏在C/C++ 中的地位仍然是不可取代的&lt;/p&gt;

&lt;p&gt;开发中，我们常用下面几种宏的写法&lt;/p&gt;

&lt;h4 id=&#34;单行宏&#34;&gt;单行宏&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define a 1
#define b (a + 1)
#define c a * b
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;多行宏&#34;&gt;多行宏&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define Vec \
static int x; \
static int y;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多行宏会在在使用处被替换为多行内容&lt;/p&gt;

&lt;h2 id=&#34;宏参数&#34;&gt;宏参数&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#define DUPLICATE(index, times) for(int index = 0; index &amp;lt; times; ++index)

int main(void) 
{ 
    DUPLICATE(i, 100) 
    {
     std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl;   
    }
    return 0; 
} 

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;和-操作符-预处理器&#34;&gt;# 和 ## 操作符 (预处理器)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Stringizing operator (#)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在类函数的宏中 # + 形参名可以在宏替换中 直接把参数字面量换成字符串&lt;/p&gt;

&lt;p&gt;例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define DEFINE_AND_PRINT(type, varname) \
type varname; \
std::cout &amp;lt;&amp;lt; &amp;quot;declare &amp;quot; &amp;lt;&amp;lt; #type &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; #varname &amp;lt;&amp;lt; std::endl;

int main(int argc, char const *argv[])
{
    DEFINE_AND_PRINT(int, bar); // declare int bar
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Token-Pasting Operator（##）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;## 直接把前后的字符合并成一个token，可以用来自动生成出一些新的token（类名，函数名，变量名等）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define CREATE_3_VARS(name) name##1, name##2, name##3
int CREATE_3_VARS(myInts);
myInts1 = 13;
myInts2 = 19;
myInts3 = 77;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;其他注意&#34;&gt;其他注意&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;由于宏本质上是预处理器对代码做的文本替换，因此一般需要一到两个括号包裹来指定优先级。&lt;/li&gt;
&lt;li&gt;注意宏替换发生在整个编译器起作用之前，即早于所谓的词法分析之前&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;2-meyer-s-singleton&#34;&gt;2. Meyer&amp;rsquo;s Singleton&lt;/h1&gt;

&lt;p&gt;我们怎样在C#中实现单例？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;public sealed class Singleton
    {
        static Singleton instance = null;
 
        public void Show()
        {
            Console.WriteLine(  &amp;quot;instance function&amp;quot;);
        }
        private Singleton()
        {
        }
 
        public static Singleton Instance
        {
            get
            {
                if (instance == null)
                {
                    instance = new Singleton();
                }
                return instance;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;线程安全&#34;&gt;线程安全&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;public sealed class Singleton
    {
        static Singleton instance = null;
        private static readonly object padlock = new object();
 
        private Singleton()
        {
        }
 
        public static Singleton Instance
        {
            get
            {
                lock (padlock)
                {
                    if (instance == null)
                    {
                        instance = new Singleton();
                    }
                }
 
                return instance;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;double-check&#34;&gt;Double-Check&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt; public sealed class Singleton
    {
        static Singleton instance = null;
        private static readonly object padlock = new object();
 
        private Singleton()
        {
        }
 
        public static Singleton Instance
        {
            get
            {
                if (instance == null)
                {
                    lock (padlock)
                    {
                        if (instance == null)
                        {
                            instance = new Singleton();
                        }
                    }
                }
                return instance;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;meyers-singleton-in-c&#34;&gt;Meyers&amp;rsquo; Singleton in C++&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static Singleton&amp;amp; instance()
{
     static Singleton s;
     return s;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（Scott Meyers 是Effective C++系列的作者）&lt;/p&gt;

&lt;p&gt;相对于C#的单例实现，Meyers提供了一种相当简洁的书写方式&lt;/p&gt;

&lt;p&gt;Meyers 单例利用了C++11 的 &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2660.htm&#34;&gt;Dynamic Initialization and Destruction with Concurrency&lt;/a&gt;[2] 特性，该特性要求编译器对于每一个静态对象都绑定一个哨兵变量（guard variable)用来做线程相关的操作，保证 static local variable 在并发条件下只执行一次Lazy Initialization。&lt;/p&gt;

&lt;p&gt;以clang 为例，Meyers 单例生成的汇编代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Singleton::instance():               # @Singleton::instance()
        push    rbp
        mov     rbp, rsp
        sub     rsp, 16
        cmp     byte ptr [guard variable for Singleton::instance()::singleton], 0
        jne     .LBB1_4
        movabs  rdi, offset guard variable for Singleton::instance()::singleton
        call    __cxa_guard_acquire
        cmp     eax, 0
        je      .LBB1_4
        mov     eax, offset Singleton::instance()::singleton
        mov     edi, eax
        call    Singleton::Singleton() [base object constructor]
        jmp     .LBB1_3
.LBB1_3:
        movabs  rdi, offset guard variable for Singleton::instance()::singleton
        call    __cxa_guard_release
.LBB1_4:
        movabs  rax, offset Singleton::instance()::singleton
        add     rsp, 16
        pop     rbp
        ret
        mov     ecx, edx
        mov     qword ptr [rbp - 8], rax
        mov     dword ptr [rbp - 12], ecx
        movabs  rdi, offset guard variable for Singleton::instance()::singleton
        call    __cxa_guard_abort
        mov     rdi, qword ptr [rbp - 8]
        call    _Unwind_Resume
Singleton::Singleton() [base object constructor]:                      # @Singleton::Singleton() [base object constructor]
        push    rbp
        mov     rbp, rsp
        mov     qword ptr [rbp - 8], rdi
        mov     rdi, qword ptr [rbp - 8]
        mov     dword ptr [rdi], 0
        pop     rbp
        ret
Singleton::instance()::singleton:
        .zero   4

guard variable for Singleton::instance()::singleton:
        .quad   0                       # 0x0
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;3-sfinae-subtitition-failure-is-not-an-error-3&#34;&gt;3.SFINAE(&lt;em&gt;subtitition failure is not an error&lt;/em&gt;) [3]&lt;/h1&gt;

&lt;h2 id=&#34;类型-sfinae&#34;&gt;类型 SFINAE&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;注意：如果有条件使用 static_assert 或者 concepts，尽量不要使用 SFINAE&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;我们经常要根据模板类型参数的不同来展开不同的代码，这这个工作有时候能利用特化完成，但也有特化无法完成的时候，比如我们想实现overload function template，就像普通函数的重载一样，这时候就需要SFINAE的帮助&lt;/p&gt;

&lt;p&gt;SFNIAE 是C++模板技术的衍生，属于模板元编程的一部分&lt;/p&gt;

&lt;h2 id=&#34;subtitition-failure&#34;&gt;Subtitition Failure&lt;/h2&gt;

&lt;p&gt;在C++ 中，模板参数的subtitition（替换） 发生在模板展开的过程中。参数替换有两步：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先发生显式指定的替换&lt;/li&gt;
&lt;li&gt;其次发生类型推断的替换，以及默认模板参数的替换&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所谓默认模板参数很好理解，和函数的默认参数一样，例子如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T, typename U = int&amp;gt; // int is the default template parameter for argument U
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当不指定 U 时，U默认为int&lt;/p&gt;

&lt;p&gt;由于替换的次序不同，在替换默认模板参数的时候，实际上可以利用已经替换过的参数来替换默认参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T, typename U = typename T::internal_type&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而替换失败(subtitition failure) 指的是上述的替换产生了问题，比如传递给类型参数A的类型可能没有一个叫internal_type的嵌套类型，&lt;/p&gt;

&lt;p&gt;然而，要使编译器产生compilation error，还需要尝试有没有别的函数模板能替换成功，这个过程可能发生多次subtitition failure。&lt;/p&gt;

&lt;p&gt;有人说那我改一下默认参数是不是能产生subtitition failure is not an error呢？很遗憾不行。只有default template parameter 不同的template是有歧义的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;

struct A {
  using internal_type = int;
};

struct B {};

template &amp;lt;typename T, typename U = typename T::internal_type&amp;gt; void foo() {
  std::cout &amp;lt;&amp;lt; &amp;quot;T has internal_type&amp;quot; &amp;lt;&amp;lt; std::endl;
}

template &amp;lt;typename T&amp;gt; void foo() {
  std::cout &amp;lt;&amp;lt; &amp;quot;T has no internal_typ&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main(int argc, char const *argv[]) {
  foo&amp;lt;A&amp;gt;(); // call to &#39;foo&#39; is ambiguous
  foo&amp;lt;B&amp;gt;();
  return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么到底如何产生 subtitition failure is not an error呢？&lt;/p&gt;

&lt;h2 id=&#34;a-simple-and-explicit-example&#34;&gt;A simple and explicit Example&lt;/h2&gt;

&lt;p&gt;Example from &lt;a href=&#34;https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error&#34;&gt;wikipedia&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct Test {
    typedef int foo;
};

template &amp;lt;typename T&amp;gt; 
void f(typename T::foo) {} // Definition #1

template &amp;lt;typename T&amp;gt; 
void f(T) {}               // Definition #2

int main() {
    f&amp;lt;Test&amp;gt;(10); // Call #1.
    f&amp;lt;int&amp;gt;(10);  // Call #2. Without error (even though there is no int::foo) thanks to SFINAE.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;typedef-detector&#34;&gt;Typedef detector&lt;/h2&gt;

&lt;p&gt;这是 SFINAE 的一个应用，用来检查类参数有没有 T 有在类内部 typedef internal_type 类型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
struct A {
  using internal_type = int;
};

template &amp;lt;typename T&amp;gt;
decltype(std::declval&amp;lt;typename T::internal_type&amp;gt;(), std::declval&amp;lt;void&amp;gt;())
foo(const T &amp;amp;) { // compare to the varadic version below, this one is more specifc
  std::cout &amp;lt;&amp;lt; &amp;quot;T has internal_type&amp;quot; &amp;lt;&amp;lt; std::endl;
}

void foo(...) { std::cout &amp;lt;&amp;lt; &amp;quot;T has no internal_type&amp;quot; &amp;lt;&amp;lt; std::endl; }

// template &amp;lt;typename T&amp;gt; void foo() { foo(int()); }

int main(int argc, char const *argv[]) {
  A a;
  foo(a);      //   subtitition suceeded for the first time
  foo(1);      //   subtitition failed, but succeeded for the second time
  foo(&amp;quot;test&amp;quot;); //   subtitition failed, but succeeded for the second time
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看到foo有两个重载版本，为了告诉编译器我期望 T 有嵌套 internal_type 类型，我们使用了 decltype + 逗号表达式 + declval。decltype(std::declval&lt;typename T::internal_type&gt;(), std::declval&lt;void&gt;()) 的真正类型是 void，但对T::internal_type进行了求值，因此编译器知道这里 T 是 more specific 的&lt;/p&gt;

&lt;h2 id=&#34;member-functor-detector&#34;&gt;member functor detector&lt;/h2&gt;

&lt;p&gt;更有用的例子是判断类型有没有包含某个名字的成员函数，这一点对template programming 中的duck typing 很重要&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;type_traits&amp;gt;

template &amp;lt;class T&amp;gt;
struct Stringlizable
{
    // We test if the type has serialize using decltype and declval.
    template &amp;lt;typename C&amp;gt;
    static constexpr decltype(std::declval&amp;lt;C&amp;gt;().serielize(), bool())
    test(int /* unused */)
    {
        // We can return values, thanks to constexpr instead of playing with sizeof.
        return true;
    }

    template &amp;lt;typename C&amp;gt;
    static constexpr bool test(...) { return false; }

    // int is used to give the precedence!
    static constexpr bool value = test&amp;lt;T&amp;gt;(int());
};

struct A
{
    int data;
    std::string to_string() { return std::to_string(data); };
};

struct B
{
};

template &amp;lt;typename T&amp;gt;
std::string Serielize(T obj) { return obj.to_string(); }

int main(int argc, char const *argv[])
{
    A a;
    B b;
    std::cout &amp;lt;&amp;lt; Serielize(a) &amp;lt;&amp;lt; std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;表达式-sfinae-略&#34;&gt;表达式 SFINAE （略）&lt;/h2&gt;

&lt;h1 id=&#34;4-type-traits&#34;&gt;4. Type Traits&lt;/h1&gt;

&lt;p&gt;终于来到了 type traits。&lt;/p&gt;

&lt;p&gt;上文中曾提到，static_assert 以及 SFINAE 和 type_traits 结合可以在编译器做一些类型约束的事情，，那么这个type_traits到底是什么呢&lt;/p&gt;

&lt;p&gt;要理解Type Traits，我们首先要理解C++的类型系统&lt;/p&gt;

&lt;p&gt;C++是一门静态类型语言，其类型系统十分强大，由三个部分组成：基本类型，RTTI， Type Traits&lt;/p&gt;

&lt;p&gt;Type traits 定义了一套编译期的，基于模板的用来查询或修改类型属性的接口&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.cppreference.com/w/cpp/header/type_traits&#34;&gt;cppreference&lt;/a&gt; [4]中列出了这些接口，它们是以 helper class 来实现的&lt;/p&gt;

&lt;p&gt;一个简单的例子是上文提到的 match unsigned 类型的泛型函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
bool check_overflow_add_unsigned(T a, T b) {
    static_assert(std::is_unsigned&amp;lt;T&amp;gt;::value, &amp;quot;T must be unsigned types!&amp;quot;);
    ...
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们终于可以尝试解释一下这个 std::is_unsigned&lt;T&gt;::value 是个什么东西了&lt;/p&gt;

&lt;p&gt;cppreference 中给出的可能实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace detail {
template&amp;lt;typename T,bool = std::is_arithmetic&amp;lt;T&amp;gt;::value&amp;gt;
struct is_unsigned : std::integral_constant&amp;lt;bool, T(0) &amp;lt; T(-1)&amp;gt; {};
 
template&amp;lt;typename T&amp;gt;
struct is_unsigned&amp;lt;T,false&amp;gt; : std::false_type {};
} // namespace detail
 
template&amp;lt;typename T&amp;gt;
struct is_unsigned : detail::is_unsigned&amp;lt;T&amp;gt;::type {};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，is_unsigned 是一个struct，其有一个static constexpr bool member 叫 value，value 继承自 std::integral_constant&lt;bool, T(0) &lt; T(-1)&gt;  或者 false_type，是一个编译期计算的量。&lt;/p&gt;

&lt;p&gt;我们从上面的代码中可以再次发现了 SFNIAE 的存在，编译器首先替换继承自 std::integral_constant 的版本，如果这个替换是invalid 的（可能是无法显式 从 -1 构造，或者编译期构造出来的 -1 &amp;gt; 0），那么将考虑更加generic 的版本，这个版本 的 is_unsigned 继承自 false_type ，这样value 就继承到了constexpr false&lt;/p&gt;

&lt;p&gt;除了 is_unsigned， &lt;a href=&#34;https://en.cppreference.com/w/cpp/header/type_traits&#34;&gt;cppreference&lt;/a&gt; 中还有非常多的helper_class， 能帮助我们写出更加 generic 的代码&lt;/p&gt;

&lt;p&gt;（注意，尝试特化&lt;type_traits&gt; 中的template是未定义行为）&lt;/p&gt;

&lt;h1 id=&#34;5-raii-resource-acquisition-is-initialization-5&#34;&gt;5. RAII(&lt;em&gt;Resource acquisition is initialization&lt;/em&gt;)[5]&lt;/h1&gt;

&lt;p&gt;RAII 可能是C++在某种程度上优于其他基于GC的语言最主要的原因&lt;/p&gt;

&lt;p&gt;简单来说，C++提供了确定性析构过程，尤其对于栈对象，异常，多返回分支语句，多线程环境C++都能保证在栈上分配的对象一定会被清理，而清理之前一定会调用对象的析构函数。&lt;/p&gt;

&lt;p&gt;同时，我们通常会在栈上创建很多临时资源，如网络连接，文件描述符，申请堆内存等。这些临时资源是需要被清理的。手动去清理他们通常会考虑不周全，通过和临时对象的析构绑定，我们可以确保资源被释放。&lt;/p&gt;

&lt;p&gt;最典型的例子其实来自于 C++ STL&lt;/p&gt;

&lt;p&gt;RAII 在 STL 中被大量使用。文件流是一个很好的例子。销毁文件流对象，也会同步关闭文件，而不需要手动关闭文件描述符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
#include &amp;lt;mutex&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt; 
#include &amp;lt;fstream&amp;gt;
#include &amp;lt;stdexcept&amp;gt;

void write_to_file (const std::string &amp;amp; message) {
    // mutex to protect file access (shared across threads)
    static std::mutex mutex;

    // lock mutex before accessing file
    std::lock_guard&amp;lt;std::mutex&amp;gt; lock(mutex);

    // try to open file
    std::ofstream file(&amp;quot;example.txt&amp;quot;);
    if (!file.is_open())
        throw std::runtime_error(&amp;quot;unable to open file&amp;quot;);
    
    // write message to file
    file &amp;lt;&amp;lt; message &amp;lt;&amp;lt; std::endl;
    
    // file will be closed 1st when leaving scope (regardless of exception)
    // mutex will be unlocked 2nd (from lock destructor) when leaving
    // scope (regardless of exception)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>道长的2018</title>
      <link>http://localhost:1313/post/%E9%81%93%E9%95%BF%E7%9A%842018/</link>
      <pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E9%81%93%E9%95%BF%E7%9A%842018/</guid>
      
        <description>

&lt;p&gt;&lt;em&gt;第一篇个人年终总结，主要目的是调整一下心态&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;2018&#34;&gt;2018&lt;/h2&gt;

&lt;p&gt;这一年过的太匆忙了&lt;/p&gt;

&lt;p&gt;上半年，在万老师那里写毕设，学生生涯快结束的时候，不想留下遗憾，那就试试搞搞学术吧。&lt;/p&gt;

&lt;p&gt;可惜的是我的工程属性太浓了，即便可能有个不错的idea，我总是关注在一些工程上的事情，比如构建系统，接口设计，等等。（这个后来在 Milo 组里做一些偏研究性的工作的时候也被 Milo 吐槽了）所以可能还是太年轻，做事情的时候关注不到重要的点上&lt;/p&gt;

&lt;p&gt;做毕设的时候，大概读过20-30篇的paper，有些重要的paper也复现过。Marching Cubes， DualContouring ，Manifold Dual Contouring 等等。我明白有时候学术上的idea需要重新走过一遍别人走得路，需要尽可能的学习现有的方法。但是这个过程对于半年的想发 paper 的毕设来说还是太漫长了&lt;/p&gt;

&lt;p&gt;paper 虽然最后成型并且投递了出去，但是要想在 SIGGRAPH ASIA这样的会议上发表还是太难了。要问为什么一个本科生敢投 SIGGRAPH ASIA，那是因为毕设这段时间是他短时间内唯一发 paper 的机会了呀&lt;/p&gt;

&lt;p&gt;当然最后是没有中，而且遗憾的是后来上班之后没有更多时间来改进 paper 并继续投了。&lt;/p&gt;

&lt;p&gt;截个 paper 中的图，算是对半年工作的一点交代吧，但全文恐怕还不能发&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./img/paper.png&#34; alt=&#34;paper&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下半年我总结一句就是：终于活成了人样&lt;/p&gt;

&lt;p&gt;旅游，社保，五险一金，租房，做饭，健身，学会工作/生活分开（但是还是很难做到 Work Life Banlance），因为基本都产出在工作上了，相对来说个人的产出减少了一些。但是相比在学校什么都不知道一门心思写代码也强太多。我觉得人的成长很多时候是想的事情的多少来决定，只不过我在这方面成长的稍微迟了一些，也可能不迟吧。很多硕士博士生其实也过得浑浑噩噩，一门心思在科研上，我曾经也在高中时期觉得理想的生活就是那样子，但是后来发现真正靠谱的事业是必须是可持续的。因此开始关注自己从大四以来的肩颈不适，关注自己一直偏瘦的体重，关注太过散漫的作息（晚起晚睡），以及作为公民关注自己的权益。&lt;/p&gt;

&lt;p&gt;来了公司发现，其实在关注自己这个方面上，有做的非常好的同事，也有做的不太好的同事，那些能做好的，心态上都有一个特点，不骄不躁。我相信有些工作是很有趣的，有些是无趣的，我能做到无趣的工作不消极，却做不到有趣的工作不要过分痴迷。&lt;/p&gt;

&lt;p&gt;我向往的理想中的工作状态是，极致的高效，这个高效不仅仅体现在心态层面上，还体现在工程层面上，工作中，能自动化的就自动化，能 fail fast 的东西就fail fast，可惜目前我还做的不够好。另外Milo亦有教会我需要在工作中给出阶段性的成果，不要想着憋一个大招，反馈是很重要的，对大任务的拆分能力也是工程能力之一&lt;/p&gt;

&lt;p&gt;来了魔方引擎中心，实属幸运，一方面是，认识了 Milo 和冰冰，在我感兴趣的领域（分别是游戏开发专业领域和自然科学）能找到远远走在前头的人（这里提一句，Milo 实在是太强了，技术，学术，生活上每天都被秒成渣渣。。。），一方面是工作室开始实行 朝九晚六 的工作制，有人说年轻人不要去不加班的公司，要拼搏啥的。我觉得呢，还是结果导向比较重要，学会长期（长期指的是几十年的长期）持续的高效输出是最重要的。&lt;/p&gt;

&lt;p&gt;另外就是这一年学会了理财，学会计算资产和负债，以及对抗通货膨胀。理财是很有趣的，这个有趣又和编程不太一样，有个朋友说的很好，投资就是你的对这个世界的认识在二级市场上的反映。虽然现在很穷，但是根据复利效应，以及不该被低估的工资收入（理论上，工资比通货膨胀涨得更快），越早进行理财，越有可能达到xx自由（哈哈扯远了）&lt;/p&gt;

&lt;h2 id=&#34;2019-flag-列表-欢迎打脸&#34;&gt;2019 Flag 列表（欢迎打脸）&lt;/h2&gt;

&lt;p&gt;计划还是要列一下的， 不然就是盲目奋斗&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;工作

&lt;ul&gt;
&lt;li&gt;工作上，持续稳定的高输出，具体metric 是 git/svn commit 的总数和日均方差（以及绩效:) ）&lt;/li&gt;
&lt;li&gt;通过脚本化自动化，尽可能提高工作效率&lt;/li&gt;
&lt;li&gt;在工作相关领域发表一篇（顶会）论文&lt;/li&gt;
&lt;li&gt;参加 3 场行业会议/比赛&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;个人技术建设

&lt;ul&gt;
&lt;li&gt;github&lt;/li&gt;
&lt;li&gt;有一个超过 100 star 的有实际意义的项目，并且有良好维护&lt;/li&gt;
&lt;li&gt;深度参与 10+ 个开源项目  全年 PR 超过 25 次&lt;/li&gt;
&lt;li&gt;知乎粉丝达到 k 级，尽量只回答专业问题，不水不抖机灵&lt;/li&gt;
&lt;li&gt;开始在 stackoverflow 上回答问题&lt;/li&gt;
&lt;li&gt;有时间多写 几个 shadertoy, 目前有 1 / 10 个作品&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;爱好/技能

&lt;ul&gt;
&lt;li&gt;做饭，研究怎么做饭好吃&lt;/li&gt;
&lt;li&gt;继续打网球，多认识一些球友&lt;/li&gt;
&lt;li&gt;英语流利说达到 v7 级别&lt;/li&gt;
&lt;li&gt;混 reddit 社区&lt;/li&gt;
&lt;li&gt;和壮壮吵架减少 20 %&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;健康

&lt;ul&gt;
&lt;li&gt;通过健身，睡眠调整，站立办公康复肩颈不适&lt;/li&gt;
&lt;li&gt;增肌+适当有氧，指标为 稍高的 BMI 和 较低的体脂率&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;理财年化收益 6 %，先苟住再说&lt;/li&gt;
&lt;li&gt;认真计划一次旅游&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>一次内存越界访问bug追踪记录</title>
      <link>http://localhost:1313/post/%E4%B8%80%E6%AC%A1%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AEbug%E8%BF%BD%E8%B8%AA%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Tue, 30 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E4%B8%80%E6%AC%A1%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AEbug%E8%BF%BD%E8%B8%AA%E8%AE%B0%E5%BD%95/</guid>
      
        <description>&lt;p&gt;最近写毕业设计，想把结果简单的用OpenGL表现一下，结果程序总是莫名其妙的随机crash，在debug模式下，这一次crash在glfw的函数内部，下一次就crash在自己的代码里，再下一次又能好好运行（三次载入的是同一个版本的程序）。&lt;/p&gt;

&lt;p&gt;刚开始我是懵逼的，因为有一段时间没写C++了，看到这样的崩溃不知道bug从何找起。而且这次遇到的错误信息貌似和以前都不一样，还有不少干扰信息&lt;/p&gt;

&lt;p&gt;我决定先复制一下这个crash的信息，然后google一下看能不能找到原因，结果搜到的都是一些其他的问题产生的bug，和我的情况完全不同，只好作罢。&lt;/p&gt;

&lt;p&gt;作为一个OpenGL/WebGL老手，我不是很敢相信是我调用OpenGL API出了问题，因为整个程序比较简单，，我出错的概率比较低。我对照官方的例子和我自己的旧代码检查了几遍，很快排除了opengl一些常见操作导致crash的可能，那么就只剩下自己的代码出问题了。&lt;/p&gt;

&lt;p&gt;可是我怎么检查也发现不了问题在哪，于是我只好一个一个注释代码，直到不crash为止&lt;/p&gt;

&lt;p&gt;这个工作相当烦，因为怀疑的点太多了！就在我快要抓狂的时候我默念一遍又一遍错误信息，突然灵光一闪：&lt;/p&gt;

&lt;p&gt;每一次crash都有错误信息如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;malloc: *** error for object 0x1001012f8: incorrect checksum for freed object
        - object was probably modified after being freed.
        *** set a breakpoint in malloc_error_break to debug
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里说已经释放的对象的校验和错误，也就是说已释放的对象可能已经被修改&lt;/p&gt;

&lt;p&gt;那么什么时候才能修改到已经释放的对象？答案是野指针或者内存越界&lt;/p&gt;

&lt;p&gt;想到这其实思路已经差不多出来了，首先我很确信程序中没有野指针，那么就只剩下内存越界了，检查几段数组操作的代码，发现是在操作Mesh的一段代码出了问题&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// 这个函数的功能很简单，利用三角形顶点数据重新计算sharp surface的法线数据
void Mesh::generateSharpNormals() {
  normals.resize(positions.size());
  std::vector&amp;lt;glm::vec3&amp;gt; flat_positions;
  std::vector&amp;lt;glm::vec3&amp;gt; flat_normals;
  std::vector&amp;lt;unsigned int&amp;gt; flat_indices;
  for (unsigned int i = 0; i &amp;lt; indices.size() / 3; ++i) {
    // 这里直接把i当做index去访问顶点数组，因此导致越界
    glm::vec3 u = positions[i * 3] - positions[i * 3 + 1];
    glm::vec3 v = positions[i * 3 + 1] - positions[i * 3 + 2];
    glm::vec3 normal = glm::normalize(glm::cross(v, u));
    for (unsigned int j = 0; j &amp;lt; 3; ++j) {
      flat_normals.push_back(normal);
      flat_positions.push_back(positions[i * 3 + j]);
      flat_indices.push_back(3 * i + j);
    }
  }
  positions = flat_positions;
  normals = flat_normals;
  indices = flat_indices;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码越界访问了堆区内存（访问的是vector内部的c array），导致后续的new校验失败，也就是说可能引起毫不相关代码的crash（但也不是完全不相关，被crash的代码应该紧接着这个越界操作不久，时间上局部性比较大）非常干扰程序员的判断&lt;/p&gt;

&lt;p&gt;下面是正确的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void Mesh::generateSharpNormals() {
  normals.resize(positions.size());
  std::vector&amp;lt;glm::vec3&amp;gt; flat_positions;
  std::vector&amp;lt;glm::vec3&amp;gt; flat_normals;
  std::vector&amp;lt;unsigned int&amp;gt; flat_indices;
  for (unsigned int i = 0; i &amp;lt; indices.size() / 3; ++i) {
    glm::vec3 u = positions[indices[i * 3]] - positions[indices[i * 3 + 1]];
    glm::vec3 v = positions[indices[i * 3 + 1]] - positions[indices[i * 3 + 2]];
    glm::vec3 normal = glm::normalize(glm::cross(v, u));
    for (unsigned int j = 0; j &amp;lt; 3; ++j) {
      // 这里扩充了整个VBO
      flat_normals.push_back(normal);
      flat_positions.push_back(positions[indices[i * 3 + j]]);
      flat_indices.push_back(3 * i + j);
    }
  }
  positions = flat_positions;
  normals = flat_normals;
  indices = flat_indices;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这真的是非常低级的一个错误，不仅导致了程序崩溃，也会导致法线数据混乱。&lt;/p&gt;

&lt;p&gt;需要注意的是，msvc 的debug mode会在vector的operator[] 检查越界，然而如果在mac使用的是libc++却不会&lt;/p&gt;

&lt;p&gt;另外，以后再遇到incorrect checksum for freed object 这样的报错信息大概就知道是怎么回事了吧。。。不过出内存问题应该首先想到跑静态分析，能省下很多痛苦的debug时间&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>KDD2017: Planning Bike Lanes based on Sharing-Bikes’ Trajectories 解读</title>
      <link>http://localhost:1313/post/kdd2017-planning-bike-lanes-based-on-sharing-bikes-trajectories-%E8%A7%A3%E8%AF%BB/</link>
      <pubDate>Sat, 28 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/kdd2017-planning-bike-lanes-based-on-sharing-bikes-trajectories-%E8%A7%A3%E8%AF%BB/</guid>
      
        <description>

&lt;p&gt;最近学校智能数据处理的作业要求阅读KDD2017，正好可以了解一点机器学习/数据挖掘的东西，简单选了一篇比较有社会影响的文章，发现读起来居然比图形学的paper好懂多了23333。大体来看数据挖掘所涉及到的知识可能还是更偏向于从基础算法出发，数学没有图形学多。不过这篇没有涉及deep learning，如果有哪方面的东西或许情况会有所不同。&lt;/p&gt;

&lt;p&gt;言归正传，这是微软亚洲研究院联合摩拜单车发表的一篇用数据驱动解决&lt;strong&gt;城市单车道路规划问题&lt;/strong&gt;的一篇paper。这篇paper背靠摩拜的大量单车数据，提出一种类似于贪心算法的解法。&lt;/p&gt;

&lt;h2 id=&#34;问题定义和抽象&#34;&gt;问题定义和抽象&lt;/h2&gt;

&lt;p&gt;政府需要对自行车道做出恰当的规划，而自行车道的规划需要综合考虑多方面的因素：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;预算限制：主要包括政府财政预算以及城市给自行车的余留空间大小&lt;/li&gt;
&lt;li&gt;便于施工和管理：施工队需要派遣到各个不同的地点铺设自行车道，为了便于管理，通常倾向于使这些车道集合成k个聚类的区域，而不是大面积分散的形式&lt;/li&gt;
&lt;li&gt;提高自行车的使用率：从政府的角度来说，希望良好规划的自行车道能提高自行车的可用性，以及覆盖更多的区域&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是一个需要考虑诸多方面的复杂问题，而要对这个问题应用算法就必须对这些条件进行抽象，我们考虑整个路面网络图为
$$
G = (V, E)
$$&lt;/p&gt;

&lt;p&gt;其中V为点集代表道路交叉点，E为边集，代表道路交叉点之间的路段。我们的自行车道规划问题的目标就是找到一个边集的子集
$$
E&amp;rsquo;
$$
来满足上述的三个条件，这三个条件抽象化即为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;每条路段铺设自行车道的经济成本为
$$
e_i.c
$$
而政府的财政总预算为B&lt;/p&gt;

&lt;p&gt;所有道路铺设自行车道的经济成本不能超过财政的总预算，即：
$$
\sum_{e_i \in E} e_i.c &amp;lt; B
$$
&lt;strong&gt;这是限制条件一&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;所有自行车道分成最多k个相关的子区域&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$$
C(E&amp;rsquo;) \leq k
$$&lt;/p&gt;

&lt;p&gt;​   其中
$$
C(E&amp;rsquo;)
$$
​   代表集合中聚类的个数&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;这是限制条件二&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;最大化使用效益&lt;/p&gt;

&lt;p&gt;主要有两个目标：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;促进更多的用户使用自行车，也即用户的覆盖数&lt;/li&gt;
&lt;li&gt;提高用户的骑行体验，覆盖更多连续的路段（一般来说，骑自行车的人希望能在连续的自行车道上行驶，而不是断断续续的自行车道）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然而这两个目标通常是冲突的，因为用户有不同的骑行路径，因此需要对每个自行车轨道
$$
tr_i
$$
设计一个可伸缩的估价函数
$$
tr_i.g
$$
对这两个目标的不同侧重将影响这个估价函数
$$
tr&lt;em&gt;i.g = \sum&lt;/em&gt;{s_j \in S_i} {\alpha^{\frac{s_j.l}{min(e.l)}} \times \frac{s_j.l}{min(e.l)}}, \alpha \ge 1
$$
其中
$$
S_i
$$
是经过轨道的&lt;strong&gt;连续片段序列&lt;/strong&gt;的集合
$$
s_j
$$
是其中的元素
$$
\frac{s_j.l}{min(e.l)}
$$
是对连续片段的长度的度量（以整个网络中最短路段长度为单位，因此这个值不会小于1），这是估价函数中的&lt;strong&gt;自变量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在估价函数中
$$
\alpha
$$
就是影响两个目标权重的参数，这个参数越小表面约侧重用户的覆盖数量，越不重视道路的连续性&lt;/p&gt;

&lt;p&gt;设计一个指数因子的目的是为了突出连续性的作用，否则这个函数将是线性的，经过最终求和之后（下面将会提到）道路连续性的影响将消除&lt;/p&gt;

&lt;p&gt;整个网络的估价函数是每条自行车轨道的估价函数之和
$$
E&amp;rsquo;.g = \sum_{tr_i \in Tr, tr_i \cap E&amp;rsquo; \ne \emptyset}tr_i.g
$$
&lt;strong&gt;这就是我们的目标函数&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;这个问题被证明是一个np-hard问题-证明过程如下&#34;&gt;这个问题被证明是一个NP-hard问题，证明过程如下：&lt;/h3&gt;

&lt;p&gt;要证明这个问题是一个NP-hard问题，只要证明这个问题和01背包问题等价即可，我们把每一个路段
$$
e_i
$$
视为背包中的一项，这个路段的经济成本以及空间成本视为这一项占据的空间，将要铺设自行车轨道的集合视为背包，其具有最大为B的空间（财政预算以及道路空间），当
$$
\alpha = 1
$$
的时候，效益函数是一个和其他项无关的量，相当于背包问题中的价格。这样，这个问题就降级成了一个01背包问题。&lt;/p&gt;

&lt;p&gt;更详细的证明略去&lt;/p&gt;

&lt;h2 id=&#34;算法的系统框架&#34;&gt;算法的系统框架&lt;/h2&gt;

&lt;p&gt;主要分为两步：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;预处理，主要包括  1)解析GPS点到轨道数据  2) 将轨道映射到路段。3）为路段建立反向索引，这样可以加快基于路段查询轨道的速度&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;贪心网络扩张算法&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这一步是整个算法的核心，又分为两步。&lt;/p&gt;

&lt;p&gt;1) 首先需要寻找到k个贪心网络的起始片段&lt;/p&gt;

&lt;p&gt;我们可以直接选择效益函数在top-k高的k个片段作为起始片段。（经过对数据集的研究，发现在共享单车轨迹起点密集处一般分布在在像大型商场这样离地铁较远的地方，被称为空间热点，而往往效益函数高的地方就在这些空间热点附近）&lt;/p&gt;

&lt;p&gt;这种方法非常直接而简单，但是，top-k高的片段往往容易集中在一起，不能很好的扩张，因此，我们采用自下而上（其实自上而下应该也是可以的）的 hierarchical spatial clustering (层次空间聚类)来帮助选出最合适的贪心网络 起始点。&lt;/p&gt;

&lt;p&gt;层次空间聚类和K-means不同，它在确定的层级总会产生稳定的结果。为了简化计算，我们首先还是需要筛选出那些效益函数排名较高的路段，作为聚类的基本元素&lt;/p&gt;

&lt;p&gt;接下来执行层次空间聚类算法，它每次都合并距离最近的两个聚类。由于这里明显用的是欧式距离，因此我们可以把聚类的中心点作为簇的位置来计算欧式距离。执行这个算法得到k个聚类，再从每一个聚类中选择效益函数最高的路段，这样我们就能得到更加“均匀分布”的贪心网络起始点。&lt;/p&gt;

&lt;p&gt;2） 进行贪心网络扩张&lt;/p&gt;

&lt;p&gt;到了这一步其实就比较简单了，我们对每一个子网络同步进行扩张，每次寻找和网络邻接的rank 最高的路段加入网络，直到满足下面条件的一个：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所有候选路段都已加入某一个网络&lt;/li&gt;
&lt;li&gt;预算被使用完&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至此，算法的主体已经阐述完毕&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;​
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;实验和评估&#34;&gt;实验和评估&lt;/h2&gt;

&lt;p&gt;为了有效的评估和验证上述算法，MSRA的研究人员利用摩拜单车在中国上海整整一个月的骑行数据来深度分析自行车轨迹。&lt;/p&gt;

&lt;p&gt;上海的城市网络拥有333,766个路口和440,922个路段。而摩拜单车在这个一个月内共有13,063个独立用户使用了3971辆共享单车，骑行了230,303次。&lt;/p&gt;

&lt;p&gt;下面两张图图给出了骑行长度和骑行时间的大致分布状况，显然，大部分骑行距离集中在相对较近的路程附近（70%的骑行短于2km），骑行时间也集中于短时。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/kdd17mobike/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下图给出了开始骑行的时间在一天之间的分布，可以看到在早/晚上下班的“冲刺阶段”是最多人选择使用共享单车的时候&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/kdd17mobike/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下图反应的则是路段的轨迹数量的分布，这是一个半对数坐标(semi-log)图，其中纵坐标为轨迹数量的对数。大部分路段的骑行轨迹数量小于100，而小部分的路段超过2000，这就证明合理的自行车道规划非常重要&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/kdd17mobike/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后是骑行轨迹的空间热点分布图，结合地图来看，大多数骑行从住宅区开始，但在早上8-10点，更多的骑行起点在地铁站&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/kdd17mobike/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;根据实验进行效益评估&#34;&gt;根据实验进行效益评估&lt;/h4&gt;

&lt;p&gt;在我们的算法中，主要有三个输入参数会明显影响总效益：聚类的个数k，预算B，以及表示对道路连续的重视程度的因子alpha。&lt;/p&gt;

&lt;p&gt;对于聚类个数
$$
k
$$
下图给出了这个实验中对不同的k使用hierarchical spatial clustering 和 top-k 对总体效益的比较。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/kdd17mobike/5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图中显示在
$$
1 \leq k \leq 9
$$
这个范围内hierarchical spatial clustering的结果总是更好，并且观察top-k的效益函数发现，当k &amp;lt; 8，总效益不变，这是由于效益高的函数往往集中在一起的缘故。&lt;/p&gt;

&lt;p&gt;对于总体预算
$$
B
$$
下图也给出了不同预算在top-k和hierarchical spatial clustering两种策略下对效益的影响。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/kdd17mobike/6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;观察发现大的预算下后者更优，当预算较小时反而前者更优，这则是因为当预算较小时把非常有限的轨道铺设在自行车骑行最为频繁的路段可能是更好的策略&lt;/p&gt;

&lt;p&gt;对于因子
$$
\alpha
$$
以下图为例，这个值越大，选择的路段集合就越纵深，越小集合就越分散越短小。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/kdd17mobike/7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;MSRA通过数据驱动的方法为自行车道的设计提供了更科学的参考，不仅如此，他们对实际路段进行了观察，发现在一些算法高度推荐修建自行车道而没有自行车道的地区常常出现自行车混杂在机动车道以及不得不在较多的停车区穿梭的现象，这无疑是危险且不符合好的城市交通建设的。实验和观察证明数据驱动的方法能在有限的预算下寻找到更好的规划方法，并得到了政府的高度评价&lt;/p&gt;

&lt;p&gt;&lt;em&gt;声明：本文系个人对原paper的部分翻译和解释，仅作个人学习用途&lt;/em&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>实时渲染中的软阴影技术</title>
      <link>http://localhost:1313/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E4%B8%AD%E7%9A%84%E8%BD%AF%E9%98%B4%E5%BD%B1%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Thu, 11 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E4%B8%AD%E7%9A%84%E8%BD%AF%E9%98%B4%E5%BD%B1%E6%8A%80%E6%9C%AF/</guid>
      
        <description>

&lt;p&gt;本文描述的是基于Shadow Mapping的软阴影技术，读者应该对Shadow Mapping 有基本的理解。&lt;/p&gt;

&lt;h3 id=&#34;关于阴影走样&#34;&gt;关于阴影走样&lt;/h3&gt;

&lt;p&gt;Shadow Mapping 有一个严重的问题就是阴影走样（Aliasing），这一点在我的渲染器CanvasToy上也非常明显
&lt;img src=&#34;http://localhost:1313/images/yyfzy/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图中阴影边缘明显的锯齿就是阴影走样&lt;/p&gt;

&lt;p&gt;阴影走样为什么会产生？以聚光灯为例，如果光源和遮挡物离场景很远，假设阴影纹理大小为1024*1024。当我们对场景中的一点找到对应shadow map中的深度，我们会在很大的矩形范围内得到同样的z(p)值，这样就形成了锯齿。&lt;/p&gt;

&lt;p&gt;除了锯齿的问题，我们发现无论遮挡物有多远，阴影的边界依然很明显，这就是所谓的硬阴影。&lt;/p&gt;

&lt;p&gt;综上，我们需要解决两个问题&lt;strong&gt;锯齿和明显的阴影边界&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;为了更好地分析问题，我们定义一个shadow test function
$$
s(x) = f(d(x), z(p))
$$
\(x\)是摄像机看到的场景中某一点，\(d(x)\) 是这一点到光源的距离，p是在阴影纹理中遮挡物的位置，z则是遮挡物的深度。
显然，对于标准阴影贴图技术
$$
f(d, z) =
\begin{cases}
1, d &amp;lt; z &lt;br /&gt;
0, d \geq z
\end{cases}
$$&lt;/p&gt;

&lt;p&gt;这个函数是离散的，我们希望对这个函数做一个变换，使其连续化。
我们可以直接对\(f(d, z)\)滤波，达到连续化的目的，然而这样的操作效率并不高，我们希望先一步对z进行滤波处理，这样我们就能在shadow pre-pass阶段进行滤波，不用在光照计算阶段进行重复的fetching和计算（这样效率很低）。
但是如果我们真的直接对z滤波，我们得不到想要的结果。原因很简单：，对\(f(d, z)\)滤波和对\(z\)滤波是完全不一样的，这里的\(f(d, z)\)是一个阶跃函数，由卷积定理，下面的式子不成立：
$$
&lt;a href=&#34;p&#34;&gt;w \ast f(d(x), z)&lt;/a&gt; \neq f(d(x),(w*z)(p))
$$
因此，我们看起来只能从\(f(d, z)\)入手，但是有些方法可以先把\(f(d, z)\)稍微变换一下，使其能满足卷积定理，从而应用pre-filtering&lt;/p&gt;

&lt;h3 id=&#34;软阴影算法概览&#34;&gt;软阴影算法概览&lt;/h3&gt;

&lt;p&gt;软阴影主要解决两个问题，1：如何高效的blur，也就是如何生成一致的软阴影 2：如何利用距离控制阴影软硬程度，并与1中的算法结合&lt;/p&gt;

&lt;p&gt;一致性软阴影：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Percentage-Closer Filter (PCF)
PCF是直接对\(f(d, z)\)滤波的方法，效率相对较低&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Variance Shadow Mapping (VSM)
VSM巧妙地利用了切比雪夫不等式，\(f(d,z)\)是一个单边的近似公式，在这种情况下，对z进行pre-filter的效果是可以接受的&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Convolution Shadow Mapping (CSM)
CSM把\(f\)变成傅里叶级数求和的形式，从而得到一系列函数的和，对这些函数就有可能应用pre-filtering&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Exponential Shadow Mapping (ESM)
ESM相当简洁，使用的是一个单边指数函数来近似，效率和空间都要好的多，支持pre-filtering&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;距离相关的阴影：
    这个方面最著名的是Percentage-Closer Soft Shadows (PCSS)&lt;/p&gt;

&lt;p&gt;本文将逐一介绍这些技术&lt;/p&gt;

&lt;h3 id=&#34;pcf滤波&#34;&gt;PCF滤波&lt;/h3&gt;

&lt;p&gt;既然要模糊阴影边缘，那我们就可以利用多重采样和插值函数，并将插值的结果作为\(f(d, z)\)的值。
这样，在阴影的边缘，离阴影越远的未被阴影照射到的部分采样结果就越接近照亮部分。&lt;/p&gt;

&lt;p&gt;由于多重采样的平均值相对于单次采样更接近期望深度，因此这个滤波算法也被称为Percentage-Closer Filter&lt;/p&gt;

&lt;p&gt;PCF是一种很朴素的思想，带来的问题也很多。
* 首先，多重采样非常影响性能，单次采样的开销取决于GPU是否支持Pre-Fetch Texture和这个采样是否是Simple Texturing（不依赖其他采样结果的采样）。但无论单次采样效率如何，多重采样在算法层面效率就低下。&lt;/p&gt;

&lt;p&gt;通过控制多重采样的范围和步长，我们可以控制采样的效率和阴影的总体软硬程度，在相同步长下，一个3x3的PCF不如一个一个5x5的PCF“软”
* 其次，PCF还不能支持pre-filtering（所谓pre-filtering是指在渲染阴影纹理的时候就进行filter滤波处理）,无法利用mipmap做完美的三线性插值&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;最后，基于采样的阴影模糊一般都会有二次走样的问题，这是基于sampling的方法无法绕过的问题&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;效率和存储&#34;&gt;效率和存储&lt;/h4&gt;

&lt;p&gt;存储：32F
PCF是是完完全全的非pre-filtering的方法，性能取决于场景复杂度和过滤核的大小，通常来说性能表现较差&lt;/p&gt;

&lt;h3 id=&#34;convolution-shadow-maps-卷积阴影&#34;&gt;Convolution Shadow Maps：卷积阴影&lt;/h3&gt;

&lt;p&gt;CSM的\(f(d,z)\)表达式为：&lt;/p&gt;

&lt;p&gt;$$
f(d,z) \approx  \frac{1}{2} + 2\sum_{k=1}^M\frac{1}{c_k}sin[c_k(d-z)]
$$&lt;/p&gt;

&lt;p&gt;其中
$$
c_k = \pi(2k-1)
$$&lt;/p&gt;

&lt;p&gt;当M取不同的值的时候，\(f(d, z)\)的曲线如下：
&lt;img src=&#34;http://localhost:1313/images/yyfzy/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;考虑到效率和实现效果，M应该取大于4的值，&lt;/p&gt;

&lt;p&gt;当d=z的时候，\(f(d, z)\)取值0.5，这显然是不对的，因为当d=z，我们应该得到一个完全无遮挡的表面，所以应对原始的函数取一点偏移, 使d=z时\(f(d, z)\)取值1，得到的函数图像如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/yyfzy/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们也可以对\(f(d, z)\)做一下变形，通过简单的\(f(d, z) \rightarrow 2f(d, z)\)，并裁剪超过1的部分，
这样也能得到可以接受的图像&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/yyfzy/5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;csm存在的问题&#34;&gt;CSM存在的问题&lt;/h4&gt;

&lt;p&gt;观察CSM的图像，在d=z的两边曲线都出现了抖动，反应在渲染结果上就是物体在和光源连线上的忽明忽暗
&lt;img src=&#34;http://localhost:1313/images/yyfzy/6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;抖动和漏光对CSM来说就像双刃剑的两面，要么抖动多一点，要么漏光多一点，
&lt;img src=&#34;http://localhost:1313/images/yyfzy/7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;效率和存储-1&#34;&gt;效率和存储&lt;/h4&gt;

&lt;p&gt;M*(R8G8B8A8) (M \geq 4)
CSM支持pre-filtering，M越大，效率越低，但比起PCF来说要好很多&lt;/p&gt;

&lt;h3 id=&#34;variance-shadow-mapping-深度概率分布和切比雪夫不等式&#34;&gt;Variance Shadow Mapping: 深度概率分布和切比雪夫不等式&lt;/h3&gt;

&lt;p&gt;为了分析阴影边缘分布的统计规律，我们考虑光源视角的深度为一个随机变量x。根据切比雪夫不等式的单边公式，深度大于给定值t的概率有一个上界
$$
p(x\geq t)  \leq \frac{\sigma^2}{\sigma^2+(t-\mu)^2}
$$
这个上界有多接近于$$p(x\geq t)$$？我们可以假设一个被称为single-bounded的理想模型。&lt;/p&gt;

&lt;p&gt;假设把深度为d1的平面投影到深度为d2的平行平面，那么在深度为d1的平面边缘，可以假设投影深度正好为d2的概率为p（这个p也可以认为是pcf的值）那么可以得到深度的期望为
$$
E(x) = pd_2+(1-p)d_1
$$
而
$$
E(x^2) = pd_2^2+(1-p)d_1^2
$$
期望的方差：
$$
\sigma^2 = E(x^2) - E(x)^2 = (p-p^2)(d_2-d_1)^2
$$
这样我们就可以根据上面提到的切比雪夫的单边公式来计算深度小于\(d_2\)的上界&lt;/p&gt;

&lt;p&gt;$$ P_{max} = \frac{\sigma^2}{\sigma^2+(\mu-d_2)^2} $$
$$ = \frac{(p-p^2)(d_2-d_1)^2}{(p-p^2)(d_2-d_1)^2 + (pd_2 + (1-p)d_1-d_2)^2} $$
$$ = \frac{(p-p^2)(d_2-d_1)^2}{(p-p^2)(d_2-d_1)^2 + (1-p)^2(d_2-d_1)^2} $$
$$ = \frac{p-p^2}{1-p} $$
$$ = p $$&lt;/p&gt;

&lt;p&gt;这个结果刚好就是p的值, 这表明，$$P_{max}$$和$$p$$在理想情况下是一样的&lt;/p&gt;

&lt;p&gt;虽然这是一种非常特殊的情况，只有一次投影，一个遮挡物，但是这个结果表明，由切比雪夫不等式计算出来的上界很可能只有一点点的偏移，我们可以直接采用这个上界作为阴影测试函数\(f\)&lt;/p&gt;

&lt;p&gt;然而，当对VSM应用一个较大核的滤波，也就是像基于VSM生成软阴影的时候，将会导致结果有较大偏差&lt;/p&gt;

&lt;h4 id=&#34;vsm的实现&#34;&gt;VSM的实现&lt;/h4&gt;

&lt;p&gt;VSM的实现关键在于渲染到深度纹理的同时渲染深度的平方，并在shading pass计算期望和方差。这个深度贴图会占用比之前多一倍的内存&lt;/p&gt;

&lt;p&gt;实现需要注意几个地方：一是在shadow pass 的时候就利用mipmap，高斯模糊等技术做好预处理，减少锯齿和突变。二是在shading 的时候，注意只有深度大于期望的时候才利用切比雪夫公式进行近似计算（这是由于计算的深度是一个上界）&lt;/p&gt;

&lt;h4 id=&#34;效率和存储-2&#34;&gt;效率和存储&lt;/h4&gt;

&lt;p&gt;存储：32+32
VSM同样支持pre-filtering但效率比CSM稳定，开销也更小&lt;/p&gt;

&lt;h3 id=&#34;exponential-shadow-mapping&#34;&gt;Exponential Shadow Mapping&lt;/h3&gt;

&lt;p&gt;在ESM中，\(s(x)\)的形式是：
$$
s(x) = f(d, z) = e^{-c(d-z)} = e^{-cd}e^z
$$&lt;/p&gt;

&lt;p&gt;显然这个表达式是单边有效的，对于d&amp;lt;z的情况，$$ e^{-cd}e^z $$ 将会爆炸式增长，我们暂时先假定\(d&amp;lt;z\)时\(f(d, z)=1\)
得到ESM的图像表示：
&lt;img src=&#34;http://localhost:1313/images/yyfzy/esmcurve.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;有了这个表达式，我们就有可能实现pre-filtering，从而提高性能。
下面的式子证明了经过ESM处理之后filtering和pre-filtering是等价的&lt;/p&gt;

&lt;p&gt;$$&lt;/p&gt;

&lt;p&gt;\begin{align}
s_f(x) &amp;amp;= &lt;a href=&#34;p&#34;&gt;w\ast f(d(x), z)&lt;/a&gt; &lt;br /&gt;
&amp;amp;= &lt;a href=&#34;p&#34;&gt;w\ast (e^{-cd(x)}e^{cz}&lt;/a&gt; &lt;br /&gt;
&amp;amp;= e^{-cd(x)}&lt;a href=&#34;p&#34;&gt;w\ast e^{cz}  &lt;/a&gt; &lt;br /&gt;
\end{align}&lt;/p&gt;

&lt;p&gt;$$&lt;/p&gt;

&lt;p&gt;常数指数c的选择会影响ESM的\(s(x)\)曲线：C越大，s(x)越陡峭，也就越接近真实的阴影；当c的值偏小的时候，会造成漏光。
C的上限受到浮点数精度的影响。32位float对应的c的经验最佳值大概在80左右，这个值生成的阴影比\(M=16\)的CSM更好&lt;/p&gt;

&lt;h4 id=&#34;esm存在的问题&#34;&gt;ESM存在的问题&lt;/h4&gt;

&lt;p&gt;下面这个图很好的反应了由shadow map精度带来的问题&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/yyfzy/8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;观察图中的边缘，发现有过亮的现象产生，我们用一张图可以清晰明了的解释&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/yyfzy/esm.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;对于阴影纹理，存储和采样点都在纹素中心，当我们计算d(x)-z(p)时就会出现小于0的情况。于是我们得到一个全白的结果，而正确结果应该是有50%的阴影&lt;/p&gt;

&lt;p&gt;这种情况出现在多重阴影的边缘，原论文中有两种解决方案，一种是增加一个&lt;/p&gt;

&lt;p&gt;$$
Z_{max}
$$&lt;/p&gt;

&lt;p&gt;的pre-pass，还有一种是对&lt;/p&gt;

&lt;p&gt;$$
e^{-cd}e^z
$$&lt;/p&gt;

&lt;p&gt;设置一个阈值\(1+\sigma\)。这两者都很好理解，&lt;/p&gt;

&lt;p&gt;$$
Z_{max}
$$&lt;/p&gt;

&lt;p&gt;的方法通过找找到附近的最大深度值来判断是否取样到了比d还远的表面，阈值检查\(e^{-cd}e^z\)是否超过某个值，若超过某个值就有可能遇到了上面的情况，就可以对附近的深度做一个PCF来修正采样误差&lt;/p&gt;

&lt;p&gt;总的来说，阈值\(1+\sigma\)的效率比Z-max要好，没有多出来的pre-pass，更何况要计算Z_{max}免不了要采样多次，虽然同时阈值的方法不能保证所有的情况，但胜在效率高，存储小。&lt;/p&gt;

&lt;h4 id=&#34;esm的实现&#34;&gt;ESM的实现&lt;/h4&gt;

&lt;p&gt;ESM只需要一个32F的浮点纹理，存储$$e^{-cd}e^z$$ 的值，之后可以直接对阴影纹理进行线性插值，高斯模糊等操作&lt;/p&gt;

&lt;h4 id=&#34;存储和效率&#34;&gt;存储和效率&lt;/h4&gt;

&lt;p&gt;：32F
ESM比之前提到的几乎所有方法都要好，不需要MRT，支持pre-filtering，没有震荡现象，可以说是最优的方案&lt;/p&gt;

&lt;h3 id=&#34;pcss&#34;&gt;PCSS&lt;/h3&gt;

&lt;p&gt;PCSS是Percentage-Closer Soft Shadows的简称。PCSS和上面的算法解决的是不同的问题。
PCSS解决了前述算法软阴影的一致性问题。原本的滤波算法不管遮挡物和阴影接收物体相距多远，都生成一致的“软”的阴影。&lt;/p&gt;

&lt;p&gt;PCSS 通过一个和光源位置相关的相似三角形来控制软阴影的&lt;strong&gt;采样搜索范围&lt;/strong&gt;。下面这个图展示了PCSS如何根据光源，遮挡物，和阴影投射目标三者确定搜索范围&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/yyfzy/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;PCSS首先假定光源是一个区域光(area light)，这看起来好像很不可思议，但其实这才是我们最常见的光源。
传统的点光源，聚光灯和平行光，其实都不过是某种模拟，比如点光源模拟小灯泡，聚光灯模拟手电筒，平行光模拟太阳，其实严格来说这些都是区域光，软阴影形成的很大一个原因就是区域光的存在。
为了在旧的光源体系中加入区域的概念，我们假定光源是一个始终平行于接收面的圆形，并用uniform变量控制这个圆形的半径
这样，我们就可以估算根据光源，遮挡物，被遮挡物三者的距离估算阴影的软硬程度&lt;/p&gt;

&lt;p&gt;计算公式:&lt;/p&gt;

&lt;p&gt;$$&lt;/p&gt;

&lt;p&gt;W&lt;em&gt;{Penumbra}=\frac{(d&lt;/em&gt;{Recevier}-d&lt;em&gt;{Blocker})\dot{w&lt;/em&gt;{Light}}}{d_{Blocker}}&lt;/p&gt;

&lt;p&gt;$$&lt;/p&gt;

&lt;p&gt;原理非常简单，就是利用了一下三角形的相似性&lt;/p&gt;

&lt;p&gt;PCSS的主要贡献在于形成了所谓“动态”的阴影，PCSS确定的这个搜索范围，也可以看做是某种模糊半径，或者卷积核的大小，并没有要求一定按照多重采样（PCF）的方式来实现，因此可以很好地和VSM，ESM等技术结合&lt;/p&gt;

&lt;h3 id=&#34;参考文献&#34;&gt;参考文献&lt;/h3&gt;

&lt;p&gt;Fernando, Randima. &amp;ldquo;Percentage-closer soft shadows.&amp;rdquo; ACM SIGGRAPH 2005 Sketches. ACM, 2005.&lt;/p&gt;

&lt;p&gt;Donnelly, William, and Andrew Lauritzen. &amp;ldquo;Variance shadow maps.&amp;rdquo; Proceedings of the 2006 symposium on Interactive 3D graphics and games. ACM, 2006.&lt;/p&gt;

&lt;p&gt;Annen, Thomas, et al. &amp;ldquo;Convolution shadow maps.&amp;rdquo; Proceedings of the 18th Eurographics conference on Rendering Techniques. Eurographics Association, 2007.&lt;/p&gt;

&lt;p&gt;Annen, Thomas, et al. &amp;ldquo;Exponential shadow maps.&amp;rdquo; Proceedings of graphics interface 2008. Canadian Information Processing Society, 2008.&lt;/p&gt;

&lt;p&gt;Bavoil, Louis. &amp;ldquo;Advanced soft shadow mapping techniques.&amp;rdquo; Presentation at the game developers conference. Vol. 2008. 2008.&lt;/p&gt;

&lt;p&gt;Shen, Li, Jieqing Feng, and Baoguang Yang. &amp;ldquo;Exponential soft shadow mapping.&amp;rdquo; Computer graphics forum. Vol. 32. No. 4. Blackwell Publishing Ltd, 2013.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>WebGL渲染引擎技术选型总结</title>
      <link>http://localhost:1313/post/webgl%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 29 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/webgl%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E6%80%BB%E7%BB%93/</guid>
      
        <description>&lt;p&gt;经过一年断断续续的踩坑，我的webgl渲染器已经到了攻坚阶段（很惭愧，离成熟还有不少距离）目前的主要工作集中在&lt;strong&gt;延迟渲染，阴影走样和PBS材质&lt;/strong&gt;的构建阶段，先放几张截图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/3.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;http://localhost:1313/images/1.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;http://localhost:1313/images/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;网站在这里：&lt;a href=&#34;http://canvastoy.com/&#34;&gt;canvas-toy&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;github: &lt;a href=&#34;https://github.com/Danielhu229/CanvasToy&#34;&gt;CanvasToy&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一个demo样式的WebGL渲染器当然是没什么意义的，我的工作当然不是只是做出上述这些简单的小渲染场景，而是要做一个封装良好同时保持先进性的渲染库。&lt;/p&gt;

&lt;p&gt;在语言层面，WebGL算是赶上了一个JavaScript技术急剧变化的潮流，这也就导致了我画了非常多时间在语言本身之上，包括不断更新项目结构以适应新的ES规范，从纯粹的JS转到TS等等。虽然我不是Web前端程序员，然而我花了很多精力保持和前端业界同样的规范。通过写这个渲染器，我深深觉得，WebGL真是有天然的技术壁垒在里面。WebGL基本等于OpenGL ES 2.0~3.0。不熟悉以及不了解图形学原理的人根本无法直接操作这些原生API，也不懂这些事什么意思。我想这也是这些渲染库存在的理由&lt;/p&gt;

&lt;p&gt;追赶潮流的代价是巨大的，却也是令人兴奋的。对于这个库，我最最明智的决定就是选用了&lt;strong&gt;TypeScript&lt;/strong&gt;。这也是对WebGL的大程序最友好的选型决定了。TypeScript的最大助力在于类型检查和代码补全，这对于有非常多类型的WebGL接口函数来说太重要了，打个比方：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;//  some code of CanvasToy
let gl: WebGLRenderingContext;
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geometry.faces.buffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(attribute.data), gl.STATIC_DRAW);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;短短两行，挂载在对象gl上的函数和数值就已经这么多了，参数同样也是非常麻烦，如果没有类型检查，得一边写代码一边开着WebGL的Specification看着，生产力十分低下，许多编译期能发现的错误全部转移到运行期了&lt;/p&gt;

&lt;p&gt;当然，TS对于自定义类型的类型支持和标注也很有用，绝对是提高生产力的好工具。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;然而麻烦的事情在node和ES6&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;众所周知，TypsScript由微软出品，质量没的说。但是，node社区和ES6的发展却稍稍落后于这个时代。JavaScript刚刚发展起来的模块系统几经修改，从commonjs到amd再到standard ES6，对开发者造成了许多困惑。我真正理解amd是在没有办法亲自写了一个amd的demo之后，在此之前，我几乎停留在 &amp;ldquo;amd&amp;rdquo; == &amp;ldquo;一种模块机制&amp;rdquo; 的认识水平上。
amd的define，require这些函数的应用场景，更多是在&lt;strong&gt;多页面应用&lt;/strong&gt;上，对于一个Web App，amd提供的按需求模块化加载的确很有用，能有效地组织源码的同时提供异步加载。但是。对于一个单页面的App，amd看起来比较&lt;strong&gt;不优雅&lt;/strong&gt;，其一在于代码可读性不高，其二在于需要一个module loader（这也是我一直对使用amd有些抗拒的原因）&lt;/p&gt;

&lt;p&gt;除了规范稍稍有些麻烦以外，JavaScript的工具链也是非常的麻烦。首先，我们从TS开始，就有一个有各种参数的tsconfig.json配置文件，这个文件制定了TS的编译参数。TS最终的target language是js，那么ts就必然有关于amd，commonjs， systemjs，umd，es6的各种模块生成配置方法。&lt;/p&gt;

&lt;p&gt;对于一个开源库来说，我们希望最终的库文件是一个单文件，也就是我们需要把所有模块打包到一个文件里。最初，TypeScript提供了internal modules，也就是namescapce，namescpace支持跨文件整合和依赖，他的依赖指定方式是在文件的首部增加一个指向性的注释&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Foo.ts&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;namespace bar {
    export class Foo {
        ...
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Fooo.ts&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;/// &amp;lt;reference path=&amp;quot;Foo&amp;quot;/&amp;gt;

namespace bar {
    export class Fooo extends Foo {
        ...
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，TypeScript就能直接编译到一个文件，然而不幸的是，这样的模块声明方式是不被推荐的，因为现在的潮流是使用标准的ES6模块（在TypeScript中被称作externel modules）。许多库都渐渐变成了这种方式&lt;/p&gt;

&lt;p&gt;如果仅仅是这样，那可能并没有什么问题。但是，如果你的项目中不幸依赖了一个external module，或者这个项目本来是internal module，但由于某些开发者基于“这样更优雅的想法”，把库更新成external module，那问题就大了。。。为了使用这个external module，你必须使用import语法来导入，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;/// &amp;lt;reference path=&amp;quot;Foo&amp;quot;/&amp;gt;
import * as SomeLib from &amp;quot;SomeLibrary&amp;quot;

namespace bar {
    export class Fooo extends Foo {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时候编译器是会报错的，因为一旦有import，整个文件就被视为一个模块，namespace bar 是在该文件内是独立的，和Foo.ts中的bar是&lt;strong&gt;两个模块&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这样带来的问题是灾难性的，想使用一个external module，就必须import，import之后，又把整个internal模块切割了，最后的解决办法是传染性的把所有的文件都换成import形式，namescpace被放弃使用。&lt;/p&gt;

&lt;p&gt;问题还没完。没有使用external module时，所有的模块能很好地编译到一个没有define，没有require的全局对象上去，所有的类和函数都在这个全局对象上&lt;/p&gt;

&lt;p&gt;这样其实是一个很好的中小型项目的解决办法，既没有污染全局命名空间，又做了良好的封装。但是JavaScript的专家说了，我们要做最先进的模块系统，于是这样的方式立马被否定了，随着各大库开始对跑在浏览器上的库使用amd，define/require反到变成优雅的方式了&lt;/p&gt;

&lt;p&gt;于是理所当然的，在更换到external module的时候，TS编译的结果是多个amd module，这些module在一个或者多个文件里，需要一个requirejs或者browserify或者webpack来做进一步的加工或处理&lt;/p&gt;

&lt;p&gt;我觉得这正是javascript令人生厌的地方，总是要经过非常麻烦的多道工序才能完成一件事情，同样的事情在C++，Java都属于根本不需要操心的事情。&lt;/p&gt;

&lt;p&gt;我没有选择requirejs或者browserify或者webpack中的一个（但是我确实折腾webpack折腾了很久，一直不能和typescript完美配合），因为毕竟我只需要把库的功能导出来，提供amd接口就够了，因为使用者应该具备&amp;rdquo;使用amd library的基础知识&amp;rdquo;&lt;/p&gt;

&lt;p&gt;除了我上述说的这些坑以外，我还在nodejs里面踩过karma，karma with requirejs，jasmine，以及组合使用ts，karma，jasmine，requirejs的巨坑。我时不时有一种后悔选了WebGL做引擎开发试水的感觉，因为我在这些别的语言早已不是问题的问题上画的时间实在是太多了&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>谈谈单元测试</title>
      <link>http://localhost:1313/post/%E8%B0%88%E8%B0%88%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Wed, 09 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E8%B0%88%E8%B0%88%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid>
      
        <description>

&lt;h3 id=&#34;是什么&#34;&gt;是什么？&lt;/h3&gt;

&lt;p&gt;很多人写了几年代码，可能连一行单元测试都没有写过。单元测试是什么？是针对程序模块（软件设计的最小单位）来进行正确性检验的&lt;strong&gt;测试&lt;/strong&gt;工作&lt;/p&gt;

&lt;p&gt;就我的理解，它是一种持续集成的手段。&lt;/p&gt;

&lt;p&gt;通常一个持续维护的项目，就算别的任何测试都没有，也几乎不会少了单元测试。尤其是库开发者，几乎会非常审慎的编写详尽的测试代码&lt;/p&gt;

&lt;h3 id=&#34;为什么&#34;&gt;为什么？&lt;/h3&gt;

&lt;p&gt;理解单元测试是一个有点hard的过程。基本上，如果你之前没写过单元测试，或者自己胡乱开始写单元测试，缺乏思考的话，那你可能一直认为unit test make no sense。&lt;/p&gt;

&lt;p&gt;单元测试有什么用？我认为最重要的主要有两点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;确保其他人修改代码后，原来的功能维持正确（这称为回归测试／regression testing）。&lt;/li&gt;
&lt;li&gt;强迫程序员设计合理的API&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;什么时候&#34;&gt;什么时候？&lt;/h3&gt;

&lt;p&gt;关于什么时候写单元测试，这是个问题。应该在编写完功能的时候写吗？或者是编写功能代码之前？还是同步进行？&lt;/p&gt;

&lt;h3 id=&#34;谁&#34;&gt;谁？&lt;/h3&gt;

&lt;p&gt;有人会误解单元测试是测试工程师的任务，但实际上的原则是，谁改动的源代码，谁就负责增加/修改/减少被影响代码的单元测试&lt;/p&gt;

&lt;h3 id=&#34;自动化&#34;&gt;自动化？&lt;/h3&gt;

&lt;p&gt;好的测试应该同时包含自动化和手工的部分，自动化测试是一个广泛的话题，所涵盖的内容不仅仅限于单元测试。&lt;/p&gt;

&lt;p&gt;推荐使用脚本或者自动化工具来做自动化测试&lt;/p&gt;

&lt;p&gt;手动测试也是必要的，否则会进入一种非常盲目的开发状态&lt;/p&gt;

&lt;h3 id=&#34;应该写多细&#34;&gt;应该写多细？&lt;/h3&gt;

&lt;p&gt;TDD他爸Kent Beck：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;老板为我的代码付报酬，而不是测试，所以，我对此的价值观是——测试越少越好，少到你对你的代码质量达到了某种自信&lt;/strong&gt;（我觉得这种的自信标准应该要高于业内的标准，当然，这种自信也可能是种自大）。如果我的编码生涯中不会犯这种典型的错误（如：在构造函数中设了个错误的值），那我就不会测试它。&lt;strong&gt;我倾向于去对那些有意义的错误做测试，所以，我对一些比较复杂的条件逻辑会异常地小心&lt;/strong&gt;。当在一个团队中，我会非常小心的测试那些会让团队容易出错的代码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我认为这是不同场景下的策略，当你在维护一个多人合作的项目时，提高覆盖率是非常有必要的，当然，这不代表有必要写冗余测试代码&lt;/p&gt;

&lt;h3 id=&#34;单元测试的弊端&#34;&gt;单元测试的弊端&lt;/h3&gt;

&lt;p&gt;好的单元测试代码通常是主体代码量的2-3倍，但是，代码量并不是单元测试的弊端。&lt;/p&gt;

&lt;p&gt;单元测试的真正问题在于，一些不够好的测试代码可能会带来隐患。并给程序员一种盲目的错觉，&lt;/p&gt;

&lt;p&gt;其次，单元测试并不是足够有效的保证，在google那样体量的公司，单元测试是远远不够的&lt;/p&gt;

&lt;p&gt;另外一个通常认为的弊端是，开发工程师通常不愿意编写测试代码，这导致一些开源项目的patch经常被打回，原因是增加的feature没有提供相应的测试代码。对于hacker来说可能非常反感单元测试&lt;/p&gt;

&lt;h3 id=&#34;一些技巧&#34;&gt;一些技巧&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;不应该编写成功通过的单元测试&lt;/strong&gt;-它们应该被写成不通过的。你可以在几分钟内让任何一组测试通过，但这只是在欺骗你自己。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;测试类应该只测试一个功能&lt;/strong&gt;-你应该用一个功能去测试一个方法。否则，你会违反了&lt;a href=&#34;https://www.jeremymorgan.com/blog/programming/single-responsibility-principle/&#34;&gt;单一职责原则&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;测试类具备可读性&lt;/strong&gt;-确保测试类标有注释并且容易理解，就像其他的代码一样。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;良好的命名规范&lt;/strong&gt;-再次测试时应该像其他代码一样-便于人们理解。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;把断言从行为中分离出来&lt;/strong&gt;-你的断言应该用来检验结果，而不是执行逻辑操作的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用具体的输入&lt;/strong&gt;-不要使用任何的自动化测试数据来输入，像date()这些产生的数据会引入差异。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;把测试类分类，放在不同的地方&lt;/strong&gt;-从逻辑的角度看，当没有错误指向特定的问题时这更容易去查找。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;好的测试都是一些独立的测试类&lt;/strong&gt;-你应该让测试类与其他的测试、环境设置等没有任何依赖。这利于创建多个测试点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要包含私有的方法&lt;/strong&gt;-他们都是一些具体的实现，不应该包含在单元测试里。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要连接数据库或者数据源&lt;/strong&gt;-这是不靠谱的。因为你不能确保数据服务总是一样的并且能够创建测试点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一个测试不要超过一个模拟(mock对象)&lt;/strong&gt;-我们努力去消除错误和不一致性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单元测试不是集成测试&lt;/strong&gt;-如果你想测试结果，不要使用单元测试。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;测试必须具有确定性&lt;/strong&gt;-你需要一个确定的预测结果，所以，如果有时候测试通过了，但是不意味着完成测试了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;保持你的测试是幂等的&lt;/strong&gt;-你应该能够运行你的测试多次而不改变它的输出结果，并且测试也不应该改变任何的数据或者添加任何东西。无论是运行一次还是一百万次，它的效果都应该是一样的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;测试类一次仅测试一个类，测试方法一次仅测试一个方法-&lt;/strong&gt;组织方法能够在问题出现时检测出来，并帮你确定测试依赖。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在你的测试里使用异常&lt;/strong&gt;-你在测试里会遇到异常，所以，请不要忽略它，要使用它。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要使用你自己的测试类去测试第三方库的功能&lt;/strong&gt;-大多数好的库都应该有它们自己的测试，如果没考虑用mocks去产生一致性的结果的话。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;限制规则&lt;/strong&gt;-当在一些规则下写测试时，记住你的限制和它们（最小和最大）设置成最大的一致性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;测试类不应该需要配置或者自定义安装&lt;/strong&gt;-你的测试类应该能够给任何人使用并且使它运行。“在我的机器上运行”不应该出现在这。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;关于测试驱动开发&#34;&gt;关于测试驱动开发&lt;/h3&gt;

&lt;p&gt;即为test-driven development, TDD。这种开发方法很难想象的会在极限编程中使用，其流程为&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;加入一个测试。&lt;/li&gt;
&lt;li&gt;运行所有测试，新的测试应该会失败。&lt;/li&gt;
&lt;li&gt;编写实现代码。&lt;/li&gt;
&lt;li&gt;运行所有测试，若有测试失败回到3。&lt;/li&gt;
&lt;li&gt;重构代码。&lt;/li&gt;
&lt;li&gt;回到 1。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;TDD 是先写测试，再实现功能。好处是实现只会刚好满足测试，而不会写了一些不需要的代码，或是没有被测试的代码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TDD太过于极端，不过非常大胆，我个人不是很倾向TDD，因为这会浪费非常多时间修改代码&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>模板元编程：C&#43;&#43;的黑魔法</title>
      <link>http://localhost:1313/post/%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8Bc&#43;&#43;%E7%9A%84%E9%BB%91%E9%AD%94%E6%B3%95/</link>
      <pubDate>Sun, 06 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8Bc&#43;&#43;%E7%9A%84%E9%BB%91%E9%AD%94%E6%B3%95/</guid>
      
        <description>

&lt;h3 id=&#34;关于模板与泛型&#34;&gt;关于模板与泛型&lt;/h3&gt;

&lt;p&gt;如果你曾经使用过template，那你一定对泛型编程有过了解，你可能在java和c#中使用过泛型代码，但是，需要注意的是，C++的泛型和java，C#一类的泛型有着根本性的不同，C++ 的泛型有个更适合的名字，叫做&lt;strong&gt;编译期多态&lt;/strong&gt;，是的，C++的泛型本质上是一种多态。&lt;/p&gt;

&lt;p&gt;怎么理解这个编译期多态？举个例子，假如你有一个template function  的定义如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
const T&amp;amp; max(const T&amp;amp; a, const T&amp;amp; b){
  return a &amp;gt; b ? a : b;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并且假设你是这样使用它的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int main() {
  float af = 0.f;
  float bf = 0.3f;
  int ai = 0;
  int bi = 1;
  std::cout &amp;lt;&amp;lt; max(af, bf) &amp;lt;&amp;lt; std::endl;
  std::cout &amp;lt;&amp;lt; max(ai, bi) &amp;lt;&amp;lt; std::endl;
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很明显，结果是0.3和0，你使用Java做上面这些事情也会得到同样的结果。但是在编译期两者做的事情是不一样的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C++编译器会把所有用到的template&lt;strong&gt;全部展开一遍，生成多份代码&lt;/strong&gt;。在上面这个例子中，template展开为参数分别为 float 和 int 的两个函数，由运行时参数决定运行哪个函数。&lt;/li&gt;
&lt;li&gt;Java编译器则会对所有用到的类型执行擦除，也就是说会把所有带类型的引用&lt;strong&gt;向上转型到Object&lt;/strong&gt;，并且在运行期需要类型化时强制转换为对应类型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意到Java泛型实现中的装箱和拆箱过程了吗？毫无疑问这会有不小的效率损失。而C++可以避免这一点。更重要的是，C++ 的泛型实现机制赋予了程序员一定的在编译期生成代码的能力(因此template这样的命名更确切一些)，有了这个，我们差不多就可以做一些事情了&lt;/p&gt;

&lt;h3 id=&#34;tamplate-参数类型&#34;&gt;tamplate 参数类型&lt;/h3&gt;

&lt;p&gt;有以下三种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;模板的类型形参 (type parameter)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
template&amp;lt;class T&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;模板的非类型形参 (non-type parameter)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;模板的非类型行参只有以下几种形式
  + 整型或枚举型
  + 到对象的指针或函数指针
  + 到对象的引用或函数引用
  + 成员指针&lt;/p&gt;

&lt;p&gt;​   因此，以下几种代码都是可以接受的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;int a&amp;gt; struct A {};
template&amp;lt;int* b&amp;gt; struct B {};
template&amp;lt;void f(int)&amp;gt; struct C{};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;模板形参 (template template parameter)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;模板行参的意思是模板里面可以是另一个模板，如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  template&amp;lt;template&amp;lt;typename T&amp;gt;&amp;gt; class X{};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;template-是图灵完备的&#34;&gt;template 是图灵完备的&lt;/h3&gt;

&lt;p&gt;所谓的图灵完备指的是以下定义&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%8F%AF%E8%AE%A1%E7%AE%97%E6%80%A7%E7%90%86%E8%AE%BA&#34;&gt;可计算性理论&lt;/a&gt;里，如果一系列操作数据的规则（如&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E9%9B%86&#34;&gt;指令集&lt;/a&gt;、&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80&#34;&gt;编程语言&lt;/a&gt;、&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%B4%B0%E8%83%9E%E8%87%AA%E5%8B%95%E6%A9%9F&#34;&gt;细胞自动机&lt;/a&gt;）可以用来模拟&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA&#34;&gt;单带图灵机&lt;/a&gt;，那么它是&lt;strong&gt;图灵完备的&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;(WikiPedia)&lt;/p&gt;

&lt;p&gt;我们可以按照百度百科的定义下去理解&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在可计算理论中，当一组数据操作的规则（一组指令集，编程语言，或者元胞自动机）满足任意数据按照一定的顺序可以计算出结果，被称为图灵完备（turing complete）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;(百度百科)&lt;/p&gt;

&lt;p&gt;一般来讲，如果一个东西能支持一个无限的递归过程，那么它就是图灵完备的，很显然，C++ template是如此特殊，它本身就是图灵完备的！&lt;/p&gt;

&lt;p&gt;理解这一点并不困难，我们把 C++ template 看做是一个特殊的图灵机，它以未做template展开的C++远代码为输入，以不带template的C++源代码为输出，在这种意义下，你甚至可以认为 template是一种只运行在编译期的语言！&lt;/p&gt;

&lt;p&gt;我们来看一个有趣的例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;

template&amp;lt;int i&amp;gt;
struct sum {
    enum {
        value = i + sum&amp;lt;i-1&amp;gt;::value
    };
};

// 对i = 1特化
template&amp;lt;&amp;gt;
struct sum&amp;lt;0&amp;gt; {
    enum{
        value = 1
    };
};

int main() {
    std::cout &amp;lt;&amp;lt; sum&amp;lt;20&amp;gt;::value &amp;lt;&amp;lt; std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好，现在编译运行它，看输出了什么？&lt;/p&gt;

&lt;p&gt;很简单，输出了211，它是 1+2+3+…+20的结果，而这个结果是编译期计算出来的！编译器在编译的时候把所有用到的template参数展开，在展开过程中 当模板实参是 i 的时候需要事先知道 i-1 的template，因此当给的实际参数是 20 的时候就会递归式的展开到 0，这样所需要的结果就在编译期算出来了，因此这是一种牺牲编译期性能来提高运行期性能的手段&lt;/p&gt;

&lt;p&gt;关于C++模板的黑魔法还有很多，我们现在看到的只是冰山一角，著名的boost库就应用了大量这种技巧。不过在真正的工程上目前还用的不是很多，其缺点也是显然的：调试困难，错误信息不可读，编译时间大幅延长。&lt;/p&gt;

&lt;p&gt;目前cpp 的 meta programming 还处在很多牛人的玩具的地位，不过能把运行期做的事情放到编译期，我相信这一特性还是非常吸引程序员的&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>新的开始</title>
      <link>http://localhost:1313/post/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</link>
      <pubDate>Sun, 27 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</guid>
      
        <description>&lt;p&gt;hexo的博客也搞了不久了，可惜换电脑的时候不小心丢失了数据，想了一些办法只恢复了几篇文章，另外还是觉得hexo的博客不够灵活。可定制化也不高，除非前端比较熟练的同学才能较好地自定义自己的主题。
之前有在写的一些算法心得，node.js的学习会继续写下去，不过接下来还是打算主要写一些图形学的东西，除了这个以外C/C++方面的一些东西有心情就会记载的。感觉还是喜欢写游戏一些，不过其他的技术也很感兴趣，技能树开的略宽了一点&amp;hellip;&lt;/p&gt;

&lt;p&gt;共勉！&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title></title>
      <link>http://localhost:1313/post/%E7%9D%80%E8%89%B2%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B8%80%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E7%9D%80%E8%89%B2%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B8%80%E7%AE%80%E4%BB%8B/</guid>
      
        <description>

&lt;p&gt;title: WebGL 着色器编程实践（一）简介
date: 2015-12-28&lt;/p&gt;

&lt;h2 id=&#34;tags&#34;&gt;tags:&lt;/h2&gt;

&lt;h3 id=&#34;webgl简介&#34;&gt;WebGL简介&lt;/h3&gt;

&lt;p&gt;WebGL是一项利用JavaScript API呈现3D电脑图形的技术，有别于过往需加装浏览器插件，通过WebGL的技术，只需要编写网页代码即可实现3D图像的展示。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;是HTML5特性之一&lt;/li&gt;
&lt;li&gt;是硬件加速的&lt;/li&gt;
&lt;li&gt;基于 OpenGL ES 2.0 的 javascript binding&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;支持情况&#34;&gt;支持情况：&lt;/h4&gt;

&lt;h6 id=&#34;桌面浏览器&#34;&gt;桌面浏览器&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;Mozilla Firefox─从4.0开始支持默认激活。&lt;/li&gt;
&lt;li&gt;Google Chrome─从9.0开始支持默认激活。&lt;/li&gt;
&lt;li&gt;Internet Explorer─从11开始支持[2]。较旧的版本可以安装第三方插件来支持，如IEWebGL.[3]&lt;/li&gt;
&lt;li&gt;Safari─在Mac OS X Snow Leopard上的Safari 5.1、OS X Mountain Lion, Mac OS X Lion上的Safari6.0或较新版本开始支持WebGL，默认情况下禁用。
Opera（需自行激活）&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;移动浏览器&#34;&gt;移动浏览器：&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;Firefox OS&lt;/li&gt;
&lt;li&gt;Firefox for mobile&lt;/li&gt;
&lt;li&gt;Google Chrome&lt;/li&gt;
&lt;li&gt;Opera Mobile&lt;/li&gt;
&lt;li&gt;Tizen&lt;/li&gt;
&lt;li&gt;Ubuntu Touch&lt;/li&gt;
&lt;li&gt;WebOS&lt;/li&gt;
&lt;li&gt;iOS&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;着色器&#34;&gt;着色器&lt;/h3&gt;

&lt;p&gt;着色器是跑在GPU上的小程序，了解着色器（shader）之前，先要了解现代显卡的渲染流程&lt;/p&gt;

&lt;h4 id=&#34;渲染流程&#34;&gt;渲染流程：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;顶点转换

&lt;ul&gt;
&lt;li&gt;model&lt;/li&gt;
&lt;li&gt;view&lt;/li&gt;
&lt;li&gt;projection&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;几何体组装&lt;/li&gt;
&lt;li&gt;光栅化&lt;/li&gt;
&lt;li&gt;片元处理

&lt;ul&gt;
&lt;li&gt;深度测试，混合操作，雾，剪切测试和模板测试&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;输出到帧缓冲区&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;固定功能管线&#34;&gt;固定功能管线：&lt;/h5&gt;

&lt;p&gt;可配置，只能给固定的几个接口传递参数&lt;/p&gt;

&lt;h5 id=&#34;可编程渲染管线&#34;&gt;可编程渲染管线：&lt;/h5&gt;

&lt;p&gt;可编程&lt;/p&gt;

&lt;p&gt;可编程渲染管线是硬件编程，我们编写的shader程序实际上是一部分的GPU执行逻辑，
具体来说，是控制了顶点处理和片元处理的逻辑，因此会非常灵活，一般来说我们用shader来自行实现光照和材质，可以用上各种光照和反射模型
，GPU是多核的，注重于并行计算，现代的GPU的并行计算能力已经超越了GPU，因此也出现了基于GPU的高性能计算接口，比如NVIDIA 的 CUDA&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;webgl使用的着色器语言-glsl&#34;&gt;WebGL使用的着色器语言：GLSL&lt;/h2&gt;

&lt;p&gt;GLSL （OpenGL Shading Language）
GLSL的着色器代码分成2个部分：Vertex Shader（顶点着色器）和Fragment（片断着色器），有时还会有Geometry Shader（几何着色器），这两种着色器一种控制顶点处理，一种控制片元处理&lt;/p&gt;

&lt;p&gt;GLSL其使用C语言语法作为基础高阶着色语言。但只是语法很相似，由于是跑在GPU上的，GLSL 提供了一些C语言不存在的一些特性，比如内建的向量和矩阵运算。也增加了一些限制，具体大家可以自己去了解&lt;/p&gt;

&lt;h5 id=&#34;其他着色器语言&#34;&gt;其他着色器语言&lt;/h5&gt;

&lt;p&gt;webGL只是基于OpenGL ES 的一个web端的接口，而OpenGL只是一个开放的硬件抽象层，与特定的硬件平台无关，除了OpenGL,还有一些基于特定平台的图形库，比较有名的是&lt;strong&gt;DirectX (Windows), metal (iOS, OSX),skia (android)&lt;/strong&gt;,使用这些图形库写出来的代码可读性都不好，大量使用了硬件相关的api，属于为了性能舍弃可移植性的选择, 学术界一般只关注OpenGL&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HLSL&lt;/strong&gt; 是基于DirectX上的只能在 windows 上跑的shader语言，在windows上有出色表现&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cg&lt;/strong&gt; 是由NVIDIA公司开发的高阶着色器语言，Cg程序是运行在OpenGL和 DirectX标准顶点和像素着色的基础上的，像引擎采用的也是Cg语言&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;在webgl上的实践&#34;&gt;在WebGL上的实践&lt;/h2&gt;

&lt;p&gt;webGL 上基本抛弃了固定功能管线, 除了javascript所控制的逻辑以外，我们可以用GLSL来控制渲染流程，并编程实现我们能想到的任意效果&lt;/p&gt;

&lt;p&gt;我们来看看著名 shader 社区 shadertoy上两个令人惊叹的效果&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.shadertoy.com/view/XsX3RB&#34;&gt;example1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.shadertoy.com/view/ldS3Wm&#34;&gt;example2&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
</description>
      
    </item>
    
    <item>
      <title>算法记录：分割回文串</title>
      <link>http://localhost:1313/post/%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</guid>
      
        <description>

&lt;h3 id=&#34;问题描述-给定一个字符串s-将s分割成一些子串-使每个子串都是回文串-返回s所有可能的回文串分割方案&#34;&gt;问题描述： 给定一个字符串s，将s分割成一些子串，使每个子串都是回文串。 返回s所有可能的回文串分割方案。&lt;/h3&gt;

&lt;h4 id=&#34;样例&#34;&gt;样例&lt;/h4&gt;

&lt;p&gt;给出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s = “aab”
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[ [&amp;quot;aa&amp;quot;,&amp;quot;b&amp;quot;], [&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;] ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路：&lt;/h3&gt;

&lt;p&gt;注意到在判断回文串的过程中，有大量的重复计算，一个回文串的判定是根据其子串是否是回文串来判断的
举个例子，有字符串&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;“abcba”
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其子串&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;”bcb“
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也是一个回文串
自然想到动态规划&lt;/p&gt;

&lt;h3 id=&#34;解法&#34;&gt;解法&lt;/h3&gt;

&lt;p&gt;维护一个二维数组，两个下标分别代表起始位置，这样一个数组元素就惟一的表示了一个字串是否是回文串，如果对应的字符串是回文串，那么置为1，否则为 -1，初始化为 0 再利用DFS搜索，由于从数组获取了信息，因此搜索过程中发生了剪枝
source code language:java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public class solution {
    private List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; cases;
    private int[][] map;
    private String insideStr;
    private Stack&amp;lt;String&amp;gt; list;

    public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; partition(String s){
        if(s==null||s.length() == 0){
            return null;
        }
        map = new int[s.length()][s.length()];
        for(int i = 0; i &amp;lt; s.length() ;++i){
            for(int j = 0; j&amp;lt;s.length();++j){
                map[i][j] = 0;
            }
        }
        insideStr = s;
        cases = new ArrayList&amp;lt;&amp;gt;();
        list = new Stack&amp;lt;&amp;gt;();
        findCase(0);
        return cases;
    }

    public void findCase(int start){
        if(start&amp;gt;=insideStr.length()){
            cases.add((Stack&amp;lt;String&amp;gt;)list.clone());
            return;
        }
        for(int i = start;i&amp;lt;insideStr.length();++i){
            int j = 0;
            boolean breakflag = false;
            while(start+j&amp;lt;=i-j) {
                if (map[start+j][i-j] == 1){
                    map[start][i] = 1;
                    break;
                }
                if(map[start+j][i-j] == -1){
                    map[start][i] = -1;
                    breakflag = true;
                    break;
                }
                if(insideStr.charAt(start+j)!=insideStr.charAt(i-j)){
                    map[start+j][i-j] = -1;
                    map[start][i] = -1;
                    breakflag = true;
                    break;
                }
                j++;
            }
            if(!breakflag){
                map[start][i] = 1;
                list.add(insideStr.substring(start, i+1));
                findCase(i + 1);
                list.pop();
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
  </channel>
</rss>
